# -*- coding:utf-8 -*-
'''
Given n points on a 2D plane, find the maximum number of points that lie on the same straight line.
Input: [[1,1],[2,2],[3,3]]
Output: 3

^
|
|        o
|     o
|  o
+------------->
'''

'''
 思路：暴力求解，每个[i]，有一个[j]连接成一条直线，用[k]来遍历所有点，查找和[i] [j] 一个方向的点

 第二种方法：把点归为2种，一种是同一个位置的点（因为0向量问题） 和 其他方向的点，记录下每个方向点的数量，求出最大 + 同一个位置的点，就等于 从[i]得到的最大数量
'''


# 暴力求解
class Soluetion(object):
    def maxPoints(self, points):
        ll = len(points)
        if ll < 3:
            return ll
        ret_count = 2
        for i in xrange(ll):
            j = 0
            stright_count = 0
            while j < ll:
                max_count = 0
                x1 = points[i][0] - points[j][0]
                y1 = points[i][1] - points[j][1]
                if (x1 == 0) and (x1 == y1):
                    j += 1
                    stright_count += 1
                    ret_count = max(ret_count, stright_count)
                    continue
                stright_count = 0
                k = 0
                while k < ll:
                    x2 = points[k][0] - points[j][0]
                    y2 = points[k][1] - points[j][1]
                    if (x1 * y2 - x2 * y1) == 0:
                        max_count += 1
                    k += 1
                ret_count = max(ret_count, max_count)
                j+=1
        return ret_count

# 优化解
class Solution(object):
    def maxPoints(self, points):
        """
        :type points: List[List[int]]
        :rtype: int
        """
        if len(points) <= 2: return len(points)
        res = 0
        for i in range(1, len(points)):
            grad, dup, inf = {}, 0, 0
            for j in range(i):
                dx = points[j][0] - points[i][0]
                dy = points[j][1] - points[i][1]
                if dx == 0 and dy == 0:
                    dup += 1  # 同一个位置的点都在一起
                elif dx == 0:
                    inf += 1  # 垂直方向都在一起
                else:
                    g = dy / float(dx)  # 记下斜率，相同直接+1
                    grad[g] = grad.get(g, 0) + 1
            if grad:
                r = max(inf, max(grad.values())) + 1 + dup # 所有方向取出最大点 + 同一位置点
            else:
                r = inf + dup + 1
            res = max(res, r)
        return res



s = Soluetion()
p = [[1,1],[2,2],[3,3]]
print s.maxPoints(p)

p = [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]
print s.maxPoints(p)

p = []
print s.maxPoints(p)

p = [[1,1], [1,1], [2,2], [2,2]]
print s.maxPoints(p)

p = [[0,9],[138,429],[115,359],[115,359],[-30,-102],[230,709],[-150,-686],[-135,-613],[-60,-248],[-161,-481],[207,639],[23,79],[-230,-691],[-115,-341],[92,289],[60,336],[-105,-467],[135,701],[-90,-394],[-184,-551],[150,774]]
print s.maxPoints(p)

p = [[1,1],[1,1],[1,1]]
print s.maxPoints(p)

p = [[40,-23],[9,138],[429,115],[50,-17],[-3,80],[-10,33],[5,-21],[-3,80],[-6,-65],[-18,26],[-6,-65],[5,72],[0,77],[-9,86],[10,-2],[-8,85],[21,130],[18,-6],[-18,26],[-1,-15],[10,-2],[8,69],[-4,63],[0,3],[-4,40],[-7,84],[-8,7],[30,154],[16,-5],[6,90],[18,-6],[5,77],[-4,77],[7,-13],[-1,-45],[16,-5],[-9,86],[-16,11],[-7,84],[1,76],[3,77],[10,67],[1,-37],[-10,-81],[4,-11],[-20,13],[-10,77],[6,-17],[-27,2],[-10,-81],[10,-1],[-9,1],[-8,43],[2,2],[2,-21],[3,82],[8,-1],[10,-1],[-9,1],[-12,42],[16,-5],[-5,-61],[20,-7],[9,-35],[10,6],[12,106],[5,-21],[-5,82],[6,71],[-15,34],[-10,87],[-14,-12],[12,106],[-5,82],[-46,-45],[-4,63],[16,-5],[4,1],[-3,-53],[0,-17],[9,98],[-18,26],[-9,86],[2,77],[-2,-49],[1,76],[-3,-38],[-8,7],[-17,-37],[5,72],[10,-37],[-4,-57],[-3,-53],[3,74],[-3,-11],[-8,7],[1,88],[-12,42],[1,-37],[2,77],[-6,77],[5,72],[-4,-57],[-18,-33],[-12,42],[-9,86],[2,77],[-8,77],[-3,77],[9,-42],[16,41],[-29,-37],[0,-41],[-21,18],[-27,-34],[0,77],[3,74],[-7,-69],[-21,18],[27,146],[-20,13],[21,130],[-6,-65],[14,-4],[0,3],[9,-5],[6,-29],[-2,73],[-1,-15],[1,76],[-4,77],[6,-29]]
print s.maxPoints(p)